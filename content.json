{"meta":{"title":"Charles Wei's Blog","subtitle":"Why so serious?","description":null,"author":"Charles Wei","url":"http://charleswei.me"},"pages":[{"title":"categories","date":"2016-08-02T12:36:28.000Z","updated":"2016-08-02T12:36:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://charleswei.me/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-08-02T12:20:20.000Z","updated":"2016-08-02T12:35:51.000Z","comments":false,"path":"tags/index.html","permalink":"http://charleswei.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android ImageView 的scaleType属性","slug":"Android-ImageView-scaleType","date":"2016-07-24T11:12:32.000Z","updated":"2016-08-02T12:39:44.000Z","comments":true,"path":"2016/07/24/Android-ImageView-scaleType/","link":"","permalink":"http://charleswei.me/2016/07/24/Android-ImageView-scaleType/","excerpt":"##Android ImageView scaleType属性介绍| 名称 | 含义 || ————- |————-|| center | 使图像在视图中居中，不缩放 || centerCrop | 以填满视图为目的，以视图中心为基准，等比缩放图像，超过视图部分做剪裁 || centerInside | 在视图中居中完全显示图像 ||matrix|从视图的左上角开始显示图像，超出视图大小部分做剪裁||fitCenter|图像等比例扩大或缩小到等于视图的宽度或高度，使图像完全显示，并居中||fitStart|等比例缩放图像使宽（高）等于视图的宽（高），使图像完全显示，并位于视图上部（左部）||fitEnd|等比例缩放图像使宽（高）等于视图的宽（高），使图像完全显示，并位于视图下部（右部）||fitXY|拉伸图像，使图像填满视图|","text":"##Android ImageView scaleType属性介绍| 名称 | 含义 || ————- |————-|| center | 使图像在视图中居中，不缩放 || centerCrop | 以填满视图为目的，以视图中心为基准，等比缩放图像，超过视图部分做剪裁 || centerInside | 在视图中居中完全显示图像 ||matrix|从视图的左上角开始显示图像，超出视图大小部分做剪裁||fitCenter|图像等比例扩大或缩小到等于视图的宽度或高度，使图像完全显示，并居中||fitStart|等比例缩放图像使宽（高）等于视图的宽（高），使图像完全显示，并位于视图上部（左部）||fitEnd|等比例缩放图像使宽（高）等于视图的宽（高），使图像完全显示，并位于视图下部（右部）||fitXY|拉伸图像，使图像填满视图| ##示例及详解示例原图 ##android:scaleType=&quot;center&quot;保持图像的大小，将图像居中显示在视图中，若图像的尺寸大于视图的尺寸，则超出视图尺寸的部分将被剪裁。如图1-1，1-2：图1-1 图1-2 ##android:scaleType=&quot;centerCrop&quot;等比例放大图像，以视图中心为基准，填满整个视图，超过视图尺寸的部分将被剪裁。如图2-1，2-2：图2-1 图2-2 ##android:scaleType=&quot;centerInside&quot;等比例缩小图像以使图像完全显示在视图中，若图像尺寸小于视图尺寸，则不对图像进行处理，居中显示。若图像尺寸大于视图，则等比例缩小图像，使图像宽（高）等于或小于视图宽（高），居中显示。如图3-1，3-2，3-3：图3-1 图3-2 缩小图像高至等于视图高 图3-3 缩小图像宽至等于视图宽 ##android:scaleType=&quot;matrix&quot;不改变图像的大小，从左上角开始显示图像，图像尺寸若大于视图尺寸，则多余的部分会被裁剪。类似center，只是图像显示的位置不同。如图4-1，4-2： 图4-1 图4-2 ##android:scaleType=&quot;fitCenter&quot;等比例放大或缩小图像使图像的高（宽）等于视图的高（宽），然后居中显示。与center的区别是fitCenter不剪裁而是缩放，以使图像全部显示；与centerCrop的区别是fitCenter不以填满视图为目的，是以全部显示图像为目的；与centerInside的却别是fitCenter等比缩放至宽或高等于视图，而centerInside则只缩小不放大。如图5-1，5-2，5-3： 图5-1 图5-2 图5-3 ##android:scaleType=&quot;fitStart&quot; android:scaleType=&quot;fitEnd&quot;fitStart：等比例缩放图像使宽（高）等于视图的宽（高），使图像完全显示，并位于视图上部（左部）。fitEnd：等比例缩放图像使宽（高）等于视图的宽（高），使图像完全显示，并位于视图下部（右部）。与fitCenter类似，只是显示图片位置的区别。如图6-1，6-2，6-3，6-4： 图6-1 图6-2 图6-3 图6-4 ##android:scaleType=&quot;fitXY&quot;以填满整个视图为目的，拉伸图片。与centerCrop的区别是fitXY不剪裁，拉伸以使图像填满，图像会变形。如图7-1： 图7-1","categories":[{"name":"Android","slug":"Android","permalink":"http://charleswei.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://charleswei.me/tags/Android/"},{"name":"ImageView","slug":"ImageView","permalink":"http://charleswei.me/tags/ImageView/"}]},{"title":"Android 身份证校验类","slug":"Android-IDCard-verify","date":"2016-07-24T11:09:31.000Z","updated":"2016-08-02T12:39:50.000Z","comments":true,"path":"2016/07/24/Android-IDCard-verify/","link":"","permalink":"http://charleswei.me/2016/07/24/Android-IDCard-verify/","excerpt":"","text":"##校验身份证是否合法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167public class IDCardUtil &#123; private String errorInfo = \"\"; public String getErrorInfo() &#123; return errorInfo; &#125; public boolean checkIDCard(String strIDCard) &#123; try &#123; String[] verifyCodes = &#123;\"1\", \"0\", \"x\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\"&#125;; String[] wCodes = &#123;\"7\", \"9\", \"10\", \"5\", \"8\", \"4\", \"2\", \"1\", \"6\", \"3\", \"7\", \"9\", \"10\", \"5\", \"8\", \"4\", \"2\"&#125;; String exEnd = \"\"; //除最后一位 // ================ 号码的长度 15位或18位 ================ if (strIDCard.length() != 15 &amp;&amp; strIDCard.length() != 18) &#123; errorInfo = \"身份证号码长度应该为15位或18位\"; return false; &#125; // ================ 数字 除最后一位都为数字 ================ if (strIDCard.length() == 18) &#123; exEnd = strIDCard.substring(0, 17); &#125; else if (strIDCard.length() == 15) &#123; exEnd = strIDCard.substring(0, 6) + \"19\" + strIDCard.substring(6, 15); &#125; if (!isNumeric(exEnd)) &#123; errorInfo = \"身份证15位号码都应为数字；18位号码除最后一位外，都应为数字\"; return false; &#125; // ================ 出生年月是否有效 ================ String strYear = exEnd.substring(6, 10);// 年份 String strMonth = exEnd.substring(10, 12);// 月份 String strDay = exEnd.substring(12, 14);// 月份 if (!isDataFormat(strYear + \"-\" + strMonth + \"-\" + strDay)) &#123; errorInfo = \"身份证生日无效\"; return false; &#125; GregorianCalendar gc = new GregorianCalendar(); SimpleDateFormat s = new SimpleDateFormat(\"yyyy-MM-dd\"); if ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) &gt; 150 || (gc.getTime().getTime() - s.parse( strYear + \"-\" + strMonth + \"-\" + strDay).getTime()) &lt; 0) &#123; errorInfo = \"身份证生日不在有效范围\"; return false; &#125; if (Integer.parseInt(strMonth) &gt; 12 || Integer.parseInt(strMonth) == 0) &#123; errorInfo = \"身份证月份无效\"; return false; &#125; if (Integer.parseInt(strDay) &gt; 31 || Integer.parseInt(strDay) == 0) &#123; errorInfo = \"身份证日期无效\"; return false; &#125; // ================ 地区码是否有效 ================ Hashtable h = GetAreaCode(); if (h.get(exEnd.substring(0, 2)) == null) &#123; errorInfo = \"身份证地区编码错误。\"; return false; &#125; // ================ 最后一位校验位计算 ================ int totalMul = 0; for (int i = 0; i &lt; 17; i++) &#123; totalMul = totalMul + Integer.parseInt(String.valueOf(exEnd.charAt(i))) * Integer.parseInt(wCodes[i]); &#125; int modValue = totalMul % 11; String strVerifyCode = verifyCodes[modValue]; exEnd = exEnd + strVerifyCode; if (strIDCard.length() == 18) &#123; if (!exEnd.equals(strIDCard)) &#123; errorInfo = \"身份证无效，不是合法的身份证号码\"; return false; &#125; &#125; else &#123; return true; &#125; return true; &#125; catch (Exception e) &#123; MyLog.info(e); return false; &#125; &#125; /** * 功能：设置地区编码 * * @return Hashtable 对象 */ private static Hashtable GetAreaCode() &#123; Hashtable hashtable = new Hashtable(); hashtable.put(\"11\", \"北京\"); hashtable.put(\"12\", \"天津\"); hashtable.put(\"13\", \"河北\"); hashtable.put(\"14\", \"山西\"); hashtable.put(\"15\", \"内蒙古\"); hashtable.put(\"21\", \"辽宁\"); hashtable.put(\"22\", \"吉林\"); hashtable.put(\"23\", \"黑龙江\"); hashtable.put(\"31\", \"上海\"); hashtable.put(\"32\", \"江苏\"); hashtable.put(\"33\", \"浙江\"); hashtable.put(\"34\", \"安徽\"); hashtable.put(\"35\", \"福建\"); hashtable.put(\"36\", \"江西\"); hashtable.put(\"37\", \"山东\"); hashtable.put(\"41\", \"河南\"); hashtable.put(\"42\", \"湖北\"); hashtable.put(\"43\", \"湖南\"); hashtable.put(\"44\", \"广东\"); hashtable.put(\"45\", \"广西\"); hashtable.put(\"46\", \"海南\"); hashtable.put(\"50\", \"重庆\"); hashtable.put(\"51\", \"四川\"); hashtable.put(\"52\", \"贵州\"); hashtable.put(\"53\", \"云南\"); hashtable.put(\"54\", \"西藏\"); hashtable.put(\"61\", \"陕西\"); hashtable.put(\"62\", \"甘肃\"); hashtable.put(\"63\", \"青海\"); hashtable.put(\"64\", \"宁夏\"); hashtable.put(\"65\", \"新疆\"); hashtable.put(\"71\", \"台湾\"); hashtable.put(\"81\", \"香港\"); hashtable.put(\"82\", \"澳门\"); hashtable.put(\"91\", \"国外\"); return hashtable; &#125; /** * 验证日期字符串是否是YYYY-MM-DD格式 * * @param str * @return */ public boolean isDataFormat(String str) &#123; boolean flag = false; String regxStr = \"^((\\\\d&#123;2&#125;(([02468][048])|([13579][26]))[\\\\-\\\\/\\\\s]?((((0?[13578])|(1[02]))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])))))|(\\\\d&#123;2&#125;(([02468][1235679])|([13579][01345789]))[\\\\-\\\\/\\\\s]?((((0?[13578])|(1[02]))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\\\-\\\\/\\\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\\\-\\\\/\\\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\\\s(((0?[0-9])|([1-2][0-3]))\\\\:([0-5]?[0-9])((\\\\s)|(\\\\:([0-5]?[0-9])))))?$\"; Pattern pattern1 = Pattern.compile(regxStr); Matcher isNo = pattern1.matcher(str); if (isNo.matches()) &#123; flag = true; &#125; return flag; &#125; /** * 功能：判断字符串是否为数字 * * @param str * @return */ private static boolean isNumeric(String str) &#123; Pattern pattern = Pattern.compile(\"[0-9]*\"); Matcher isNum = pattern.matcher(str); if (isNum.matches()) &#123; return true; &#125; else &#123; return false; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://charleswei.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://charleswei.me/tags/Android/"}]},{"title":"Android_CrashHandler 自定义崩溃异常捕获","slug":"Android-CrashHandler","date":"2016-07-24T09:23:13.000Z","updated":"2016-08-02T12:39:56.000Z","comments":true,"path":"2016/07/24/Android-CrashHandler/","link":"","permalink":"http://charleswei.me/2016/07/24/Android-CrashHandler/","excerpt":"#当APP 异常崩溃时，使用Toast提示，并关闭APP，收集错误信息保存并上报 需求：由于android机型的碎片化，我们在开发时无法对所以机型进行测试，因此在可能的崩溃发生时，我们应当做一些事情来为我们提供更多信息以便改进，同时也能然崩溃发生时的用户体验得到一些改善。例如程序崩溃后的重启APP、系统dialog等并不为我们想要，因此可以在APP崩溃时进行一些处理。由于现在一些第三方提供的崩溃日志的捕获上传做得也不错，对于类似我们这些中小型公司，可以集成如腾讯的Bugly、百度的测试云平台等第三方SDK进行崩溃日志的收集及上传，在我们自定义的CrashHandler里做一些交互处理即可。如使用Toast进行崩溃提示、在崩溃时关掉APP避免重启。","text":"#当APP 异常崩溃时，使用Toast提示，并关闭APP，收集错误信息保存并上报 需求：由于android机型的碎片化，我们在开发时无法对所以机型进行测试，因此在可能的崩溃发生时，我们应当做一些事情来为我们提供更多信息以便改进，同时也能然崩溃发生时的用户体验得到一些改善。例如程序崩溃后的重启APP、系统dialog等并不为我们想要，因此可以在APP崩溃时进行一些处理。由于现在一些第三方提供的崩溃日志的捕获上传做得也不错，对于类似我们这些中小型公司，可以集成如腾讯的Bugly、百度的测试云平台等第三方SDK进行崩溃日志的收集及上传，在我们自定义的CrashHandler里做一些交互处理即可。如使用Toast进行崩溃提示、在崩溃时关掉APP避免重启。 ###步骤 创建CrashHandler类，继承UncaughtExceptionHandler 接口 编写崩溃处理逻辑 在自定义application中注册CrashHandler 代码块1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CrashHandler implements Thread.UncaughtExceptionHandler &#123; private static CrashHandler instance = new CrashHandler(); private Context mContext; private CrashHandler() &#123;&#125; public static CrashHandler getInstance() &#123; return instance; &#125; public void setCustomCrashHanler(Context context) &#123; mContext = context; //崩溃时将catch住异常 Thread.setDefaultUncaughtExceptionHandler(this); &#125;//崩溃时触发 @Override public void uncaughtException(Thread thread, Throwable ex) &#123; //使用Toast进行提示 showToast(mContext, \"很抱歉，程序异常即将退出！\"); //延时退出 try &#123; thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //关闭APP Util.exic(); &#125;//线程中展示Toast private void showToast(final Context context, final String msg) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); Toast.makeText(context, msg, Toast.LENGTH_LONG).show(); Looper.loop(); &#125; &#125;).start(); &#125;&#125; 在自定义Application的onCreate()函数中注册CrashHandle.1234567@Override public void onCreate() &#123; super.onCreate(); CrashHandler crashHandler = CrashHandler.getInstance(); crashHandler.setCustomCrashHanler(getApplicationContext()); ...... &#125; 如果是首次自定义Application，别忘了在AndroidManifest.xml中注册。123&lt;application android:name=\".MyApplication\" ...... 自定义工具类，关闭所有activity以关闭APP。1234567891011121314151617181920212223242526272829public class Util &#123; public static List&lt;Activity&gt; activityList = new LinkedList&lt;Activity&gt;(); public static void addActivity(Activity activity) &#123; activityList.add(activity); &#125; public static void removeActivity(Activity activity) &#123; if (activityList != null) &#123; boolean bResult = activityList.remove(activity); while (bResult) &#123; bResult = activityList.remove(activity); &#125; &#125; &#125; public static void exic()&#123; if (activityList.size() &gt; 0) &#123; for (Activity activitys : MyActivity.activityList) &#123; try &#123; activitys.finish(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; System.exit(0); &#125;&#125; 在自定义的activity基类的onCreate()和onDestroy()中调用。 12345678910111213@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Util.addActivity(this); ...... &#125;@Overrideprotected void onDestroy() &#123; removeActivity(_this); ...... super.onDestroy(); &#125; 最后在程序的一处写个异常如 int i=1/0; 运行到那里进行异常测试。","categories":[{"name":"Android","slug":"Android","permalink":"http://charleswei.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://charleswei.me/tags/Android/"}]},{"title":"Hexo的安装和使用（mac篇）","slug":"HowToInstallHexoForMac","date":"2016-07-21T13:54:41.000Z","updated":"2016-07-24T09:14:45.000Z","comments":true,"path":"2016/07/21/HowToInstallHexoForMac/","link":"","permalink":"http://charleswei.me/2016/07/21/HowToInstallHexoForMac/","excerpt":"前言Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。官方文档传送门。Hexo的安装是个很快速简便的过程，但依然还是有不少坑。这里记录个我的安装过程，给大家一些参考。以下是我安装时系统及软件版本，请尽量保证不低于这些版本号： OS ： OS X EI Capitan 10.11.3 XCode : 7.3 hexo : 3.2.2 node : 4.4.7 git : 2.6.4","text":"前言Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。官方文档传送门。Hexo的安装是个很快速简便的过程，但依然还是有不少坑。这里记录个我的安装过程，给大家一些参考。以下是我安装时系统及软件版本，请尽量保证不低于这些版本号： OS ： OS X EI Capitan 10.11.3 XCode : 7.3 hexo : 3.2.2 node : 4.4.7 git : 2.6.4 安装安装前提需要安装 Node.js 和 Git 两个应用程序，直接到官网安装最新版本即可，如已安装请跳过。 Node.js 官网 Git 官网 安装Hexo安装完Node.js 及 Git 后，即可使用npm来安装Hexo： 1$ npm install -g hexo-cli 初始化Hexo创建一个目录用来作为你的blog目录，例如 MyBlog；并在该目录中进行Hexo的初始化： 123$ hexo init MyBlog$ cd ~/MyBlog/$ npm install 新建完成后，得到以下目录： 12345678·|-- _config.yml|-- package.json|-- scaffolds|-- source| |-- _drafts| |-- _posts|-- themes 至此，你就完成了Hexo的安装及初始化，接下来我们就可以进行本地的预览啦：先安装hexo server1$ sudo npm install hexo-server 然后生成静态页面并打开hexo本地服务12$ hexo generate (或 hexo g)$ hexo server 按命令行提示，打开 http:\\/\\/localhost:4000\\/ 即可看到默认主题的默认页面了。可能加载会很慢，因为默认主题中使用了些Google的资源，后面更换主题就会快很多了。 配置与Github账户关联首先需要去Github注册一个账号，并新建一个名为 [your_account].github.io 的仓库。然后打开前面创建的MyBlog目录下的 _config.yml 文件，在修改最下方的deploy为：*注意，冒号后面一定要加空格1234deploy: type: git repo: gihub: https://github.com/[your_account]/[your_accout].github.io.git branch: master 接下来安装hexo的git部署，在命令行中执行：1$ npm install hexo-deployer-git --save 最后，将生成静态页面并部署到github的仓库中，执行：1234$ hexo d -g 或者$ hexo generate$ hexo deploy 当提示 INFO Deploy done: git 即上传成功，这时就可以通过 http:\\/\\/[your_account].github.io 来访问你的个人站点了。这里涉及了github pages 的相关内容，有兴趣的可以去了解一下。 hexo的基本配置以下是hexo配置文件 _config.yml 的基本内容及基本设置，更多个性化设置请参考官方文档：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Site ##页面信息title: Who's Blog ##标题，即浏览器标签栏显示的内容subtitle: Why so serious? ##副标题description: ##描述，简介author: Charles Wei ##作者language: zh-CN ##语言timezone: Asia/Shanghai ##时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://wwww.charleswei.me ##域名，后面自定义域名后，写在这里，用 .github.io的话，这里用默认的不用改root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory ##文件目录，可不改source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing ##静态页面生成属性，可不改new_post_name: :year-:month-:day-:title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag ##标签，可不改default_category: uncategorizedcategory_map:tag_map:# Date / Time format ##时间格式，可不改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ##每页显示文章数，按需改## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions ##主题设置## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo# Deployment ##git部署关联## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/glassweichao/glassweichao.github.io.git branch: master 主题配置Hexo具有高定制的主题效果，你可以从Hexo的主题库中选择合适的主题，也可以自己制作。以我现在使用的indigo主题为例。首先将主题库clone到MyBlog目录下的themes目录：1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 安装less，主题使用less作为css预处理工具：1npm install hexo-renderer-less --save 安装feed,用于生吃RSS：1npm install hexo-generator-feed --save 安装json-content，用于生成静态站点数据，提供搜索功能的数据源：1npm install hexo-generator-json-content --save 开启标签页：1hexo new page tags 修改12345```layout: tagsnoDate: truecomments: false--- 修改hexo配置文件12```theme: indigo 最后修改主题配置文件12 #添加新菜单项遵循以下规则 menu:link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写url: /about 链接，绝对或相对路径，必须。target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/glassweichao target: _blank link: text: 测试 url: /404rss: /atom.xml #你的头像,替换掉 indigo/source/img/logo.jpg 即可urlavatar: /img/logo.jpg Contenttags: title: 标签 #是否开启分享share: true #是否开启搜索search: true #是否大屏幕下文章页隐藏导航hideMenu: true #是否开启toc #toc: false 关闭toctoc: list_number: true # 是否显示数字排序 #浏览器标签栏小图标favicon: /favicon.ico1234最后生成部署，来看看效果吧```bashhexo cleanhexo d -g","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://charleswei.me/tags/hexo/"}]}]}